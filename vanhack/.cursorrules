# Rules for Woven Evaluation - Backend PHP

## ‚ö†Ô∏è CRITICAL: ASSESSMENT MODE RULES

**When user is doing an ASSESSMENT (evaluaci√≥n/test):**

1. **‚ùå DO NOT create files** - Never use write_file, search_replace, or any file creation tools
2. **‚ùå DO NOT update files** - Never modify existing files
3. **‚ùå DO NOT save anything** - Only display code/responses in chat
4. **‚úÖ Display everything in chat** - Show code, solutions, explanations directly in the conversation
5. **‚úÖ Fast responses** - Give answers as quickly as possible, prioritize speed
6. **‚úÖ Solutions by levels** - Show STEP 1 (basic), STEP 2 (improved), STEP 3 (final) - progressive solution
7. **‚è∏Ô∏è Wait for "finalizar"** - Only when user says "finalizar" or "guardar" or "save", then save everything

**These rules apply ONLY during active assessment. User will explicitly say when assessment starts/ends.**

## üìÅ SAVE ON "FINALIZAR" - MANDATORY

**When user says "finalizar", "guardar", or "save", you MUST:**

1. **Create folder structure:**
   - Path: `resoluciones-examenes/` (in workspace root)
   - Create folder if it doesn't exist

2. **Create file with format:**
   - Filename: `YYYY-MM-DD_[assessment-name].md`
   - Example: `2025-01-15_woven-median-sorted-arrays.md`
   - Example: `2025-01-15_woven-minimum-time-visiting-points.md`

3. **File content MUST include:**
   - **Date and time** of the assessment
   - **Assessment name/title** (e.g., "Woven - Median of Two Sorted Arrays")
   - **Problem description** (full problem statement)
   - **Research phase** (if any):
     - Research topics suggested
     - Resources consulted
     - Key learnings
   - **STEP 1: Basic Solution**
     - Explanation
     - Complete code (WITH debug/logging statements)
     - Debug/logging output examples
     - All test cases
     - Test results (if available)
   - **STEP 2: Improvements**
     - Explanation of changes
     - Complete code
     - Additional test cases
     - Test results (if available)
   - **STEP 3: Final Solution**
     - Final explanation
     - Complete code
     - Complete test suite
     - Test results (if available)
   - **Validation/Results:**
     - Which tests passed
     - Which tests failed (if any)
     - Error messages (if any)
     - Final status
   - **Notes/Learnings:**
     - Key insights
     - Challenges faced
     - Solutions found
     - Time taken (if mentioned)
   - **Complete conversation context** - All Q&A during the exercise

4. **File format:**
   - Markdown format (.md)
   - Well-structured with headers
   - Code blocks properly formatted
   - Easy to read and review later

**Example file structure:**
```markdown
# Assessment: [Name]
**Date:** 2025-01-15
**Time:** 14:30
**Platform:** Woven / LeetCode / etc.

## Problem Description
[Full problem statement]

## Research Phase
[Research topics and findings]

## Solutions

### STEP 1: Basic Solution
[Explanation, code, tests, results]

### STEP 2: Improvements
[Explanation, code, tests, results]

### STEP 3: Final Solution
[Explanation, code, tests, results]

## Validation
[Test results, errors, final status]

## Notes
[Key learnings, challenges, insights]
```

**IMPORTANT:** Save ALL information from the exercise, including failed attempts, error messages, and the complete thought process.

## üß† NATURAL HUMAN DEVELOPMENT PROCESS - MANDATORY

**IMPORTANT: Solutions must simulate REAL human development process, not just show final code!**

**The development process MUST follow this natural human workflow:**

### Phase 0: Understanding the Problem (Human Thinking)

**Before any code, show human thought process:**

1. **Read and analyze** - "Let me understand what this problem is asking..."
2. **Break down the problem** - "So I need to..."
3. **Think about examples** - "Let me trace through the examples manually..."
4. **Identify key concepts** - "This seems like a [pattern/algorithm] problem..."
5. **Consider edge cases** - "What about empty inputs? Single element? etc."

**Show this thinking process in natural language before coding.**

### Phase 1: Manual Testing & Exploration (Human Approach)

**Before writing code, humans test manually:**

1. **Trace examples by hand:**
   - "Let me trace Example 1 step by step..."
   - Show manual calculation
   - Show intermediate values
   - Verify the expected output

2. **Test with simple inputs:**
   - "Let me try with a simple case first..."
   - Test with minimal data
   - See what happens
   - Understand the pattern

3. **Identify what we need to track:**
   - "I need to keep track of..."
   - Variables needed
   - Data structures needed
   - State management

**Show this exploration process before STEP 1 code.**

### Phase 2: Incremental Development (Real Human Process)

**STEP 1 should show REAL incremental development:**

1. **Start with simplest possible code:**
   - "Let me start with the most basic version..."
   - Just handle the happy path
   - Maybe even incomplete
   - Test it immediately

2. **Add debug/logging to see what's happening:**
   - "Let me add some logging to see what's going on..."
   - Print inputs
   - Print intermediate values
   - Print outputs
   - Verify each step

3. **Test with provided examples:**
   - "Let me test with Example 1..."
   - Run through manually with code
   - Check if output matches
   - If not, debug why

4. **Fix issues as they appear:**
   - "Hmm, that didn't work. Let me check..."
   - Show the error or wrong output
   - Think about why
   - Fix it
   - Test again

5. **Add edge cases one by one:**
   - "Now let me handle empty array..."
   - Test it
   - "Now let me handle single element..."
   - Test it
   - Build up incrementally

### Phase 3: Refinement Based on Senior Experience

**STEP 2 and STEP 3 show senior-level refinement:**

1. **Review what we have:**
   - "Looking at my solution, I notice..."
   - Identify inefficiencies
   - Identify missing cases
   - Think about production scenarios

2. **Apply senior knowledge:**
   - "Based on my experience with [similar problem]..."
   - "I know from PostgreSQL optimization that..."
   - "In microservices, we usually..."
   - Apply real-world patterns

3. **Optimize and improve:**
   - "I can optimize this by..."
   - Consider time/space complexity
   - Apply design patterns if relevant
   - Make it production-ready

### Format for Natural Development:

```
## Understanding the Problem

Let me break down what this problem is asking:
- [Analysis in natural language]
- [Key requirements]
- [Edge cases to consider]

## Manual Testing

Let me trace through Example 1 manually:
- Input: [example]
- Step 1: [manual calculation]
- Step 2: [manual calculation]
- Expected output: [result]
- This tells me I need to [insight]

## STEP 1: Basic Solution (Incremental Development)

**My thinking:** I'll start with the simplest approach...

**First attempt - just the happy path:**
[code with lots of debug]

**Testing with Example 1:**
[show debug output]
[show what we learned]

**Found an issue - let me fix it:**
[show the problem]
[show the fix]
[test again]

**Now let me add edge case handling:**
[incremental addition]
[test it]

[Final STEP 1 code with all debug]
```

**This simulates REAL human development:**
- ‚úÖ Not perfect from the start
- ‚úÖ Test and fix incrementally
- ‚úÖ Learn from each test
- ‚úÖ Build up the solution
- ‚úÖ Show the thinking process
- ‚úÖ Make mistakes and fix them
- ‚úÖ Apply experience gradually

## üîç RESEARCH PROCESS - MANDATORY FOR ASSESSMENTS

**IMPORTANT: Research is ENCOURAGED and VALUED in Woven assessments!**

**When solving an assessment problem, you MUST follow this research process:**

### Step 0: Research Phase (BEFORE coding)

**Before providing STEP 1 solution, you should:**

1. **Analyze the problem** - Understand requirements, constraints, examples
2. **Identify research needs** - What concepts/algorithms/patterns are needed?
3. **Suggest research topics** - What should the user look up?
4. **Provide research guidance** - Where to search and what to look for

**Research is allowed and encouraged:**
- ‚úÖ StackOverflow - For specific implementation questions
- ‚úÖ Blog posts - For explanations and tutorials
- ‚úÖ Official documentation - PHP manual, framework docs, etc.
- ‚úÖ Algorithm explanations - For understanding approaches
- ‚úÖ Code examples - For reference (must cite sources)

**Research topics to consider:**
- Algorithm patterns (two pointers, binary search, etc.)
- Data structures needed
- PHP-specific functions or methods
- Edge cases and common pitfalls
- Performance optimizations
- Best practices for the problem type

### Research Workflow:

```
1. User provides problem
2. AI analyzes and suggests research topics
3. User researches (StackOverflow, docs, blogs)
4. AI provides STEP 1 solution based on research
5. Continue with STEP 2, STEP 3 as normal
```

**Example Research Suggestions:**

For "Median of Two Sorted Arrays":
- "Binary search on two sorted arrays"
- "Finding median in O(log n) time"
- "Partition algorithm for sorted arrays"
- "LeetCode median of sorted arrays approach"

For "Minimum Time Visiting All Points":
- "Chebyshev distance calculation"
- "Diagonal movement optimization"
- "Manhattan vs Chebyshev distance"

**After research, provide solution with:**
- Comments citing concepts learned from research
- References to algorithms/patterns used
- Clear explanation of approach
- **If using code from sources, MUST cite them** (required by Woven Code of Conduct)

**Citing Sources (REQUIRED if using others' code):**
- If you use code snippets from StackOverflow, blogs, or documentation
- Add a comment with source URL: `// Source: https://stackoverflow.com/...`
- Or: `// Based on approach from: [URL or source name]`
- This is MANDATORY per Woven Code of Conduct

**This process shows:**
- ‚úÖ Research skills (valued by Woven)
- ‚úÖ Ability to learn and apply new concepts
- ‚úÖ Professional development approach
- ‚úÖ Understanding of when to look things up
- ‚úÖ Ethical coding practices (citing sources)

## CRITICAL: MANDATORY CODE EVOLUTION DISPLAY

**EVERY TIME code is generated, you MUST show the evolution step by step following NATURAL HUMAN DEVELOPMENT:**

### Pre-Code Phase: Human Thinking Process

**BEFORE writing any code, show:**

1. **Problem Understanding (Natural Language):**
   - "Let me understand what this problem is asking..."
   - Break down requirements
   - Identify key constraints
   - Think about what we need to achieve

2. **Manual Example Tracing:**
   - "Let me trace through Example 1 manually..."
   - Show step-by-step manual calculation
   - Show intermediate values
   - Verify expected output
   - "This tells me I need to track..."

3. **Simple Case Testing:**
   - "Let me try with a simple case first..."
   - Test with minimal input
   - See what pattern emerges
   - "I notice that..."

4. **Variable Identification:**
   - "I'll need to keep track of..."
   - List variables needed
   - Data structures needed
   - State management

### STEP 1: Incremental Development (Real Human Process)

**Show REAL incremental development, not perfect code:**

1. **Start with absolute simplest version:**
   - "Let me start with the most basic version - just handle the happy path..."
   - Maybe even incomplete or wrong initially
   - Show this first attempt

2. **Add debug/logging immediately:**
   - "Let me add logging to see what's happening..."
   - Print all inputs
   - Print intermediate values at each step
   - Print outputs
   - Show variable states

3. **Test with first example:**
   - "Let me test with Example 1..."
   - Show the debug output
   - Show what we expected vs what we got
   - "Hmm, I see that..."

4. **Fix issues as they appear:**
   - "That didn't work as expected. Let me check..."
   - Show the problem (wrong output, error, etc.)
   - Think about why: "I think the issue is..."
   - Fix it: "Let me adjust..."
   - Test again: "Now let me test again..."
   - Show new debug output

5. **Add features incrementally:**
   - "Now let me handle the case where..."
   - Add one feature at a time
   - Test it immediately
   - "Good, that works. Now let me add..."
   - Continue building up

6. **Test edge cases one by one:**
   - "Let me test with empty array..."
   - See what happens
   - Fix if needed
   - "Now let me test with single element..."
   - Continue incrementally

**STEP 1 Requirements:**
   - **MUST show the thinking process** before code
   - **MUST show manual example tracing**
   - **MUST start with simplest version** (maybe even wrong)
   - **MUST include DEBUG/LOGGING** throughout
   - **MUST show incremental fixes** (not perfect from start)
   - **MUST test after each change**
   - **MUST show debug output** for each test
   - **MUST include MULTIPLE test cases (3-5 minimum)**
   - **MUST include a BRIEF EXPLANATION** of what we learned from testing
   
2. **STEP 2: Improvements** - Add edge cases, validations, optimizations
   - **MUST include a BRIEF EXPLANATION** of what changed and why
   - "Looking at my solution, I notice..."
   - "Based on my experience with [similar problem]..."
   - Show senior-level thinking
   - Include additional tests for newly discovered edge cases
   - May include debug/logging for new edge cases being tested
   
3. **STEP 3: Final version** - With comments explaining the evolution
   - **MUST include a BRIEF EXPLANATION** summarizing the complete solution
   - "Based on my senior experience, I can optimize this by..."
   - Apply real-world patterns from your profile
   - Include complete test suite covering all scenarios
   - Debug/logging can be removed or commented out (show both versions)
   - Show production-ready considerations

**This is MANDATORY for ALL code generation requests. Never show only the final version.**

## MANDATORY: EXPLANATION FOR EACH STEP

**EVERY solution step MUST include a brief explanation:**

### Format for Explanations:

**STEP 1 Explanation should include:**
- What the solution does (high-level approach)
- Key algorithm/pattern used
- Why this approach was chosen
- Time/space complexity (if relevant)
- Brief: 2-4 sentences maximum

**STEP 2 Explanation should include:**
- What changed from STEP 1
- Why the changes were needed
- Edge cases addressed
- Brief: 2-3 sentences maximum

**STEP 3 Explanation should include:**
- Summary of the complete solution
- Final approach and optimizations
- Key insights or learnings
- Brief: 3-5 sentences maximum

## MANDATORY: DEBUG/LOGGING IN STEP 1

**STEP 1 MUST include debug/logging statements to show step-by-step testing:**

### Debug/Logging Requirements:

1. **Show variable values** at key points
2. **Log intermediate steps** in the algorithm
3. **Display decision points** (if/else conditions)
4. **Track loop iterations** (for complex loops)
5. **Show function inputs/outputs** for debugging
6. **Show manual testing process** - trace through examples
7. **Show incremental fixes** - when something doesn't work, show the fix
8. **Show learning from tests** - what we discovered from each test

### Natural Development Flow in STEP 1:

**Before code:**
- Manual trace of examples
- Identify what variables we need
- Think about the approach

**In code:**
- Start with simplest version
- Add debug immediately
- Test with first example
- See what happens
- Fix if needed
- Test again
- Add next feature incrementally
- Test again
- Continue building up

**This shows REAL human development, not just final code.**

### Debug/Logging Format:

**Use appropriate logging for the language:**
- PHP: `error_log()`, `var_dump()`, or `print_r()`
- Include comments explaining what we're debugging
- Show expected vs actual values when testing

### Example with Debug/Logging:

```php
## STEP 1: Basic Solution

**Explanation:**
This solution uses a two-pointer approach to merge the arrays, then finds the median.
We iterate through both arrays simultaneously, comparing elements and building a merged array.
Time complexity: O(m+n), Space: O(m+n). This is straightforward but not optimal.

**Debug/Logging included to show step-by-step testing process.**

```php
function findMedianSortedArrays($nums1, $nums2) {
    $merged = [];
    $i = 0;
    $j = 0;
    
    // Debug: Show initial state
    error_log("Starting merge: nums1=" . json_encode($nums1) . ", nums2=" . json_encode($nums2));
    
    while ($i < count($nums1) && $j < count($nums2)) {
        // Debug: Show comparison step
        error_log("Comparing: nums1[$i]={$nums1[$i]} vs nums2[$j]={$nums2[$j]}");
        
        if ($nums1[$i] <= $nums2[$j]) {
            $merged[] = $nums1[$i];
            error_log("Added nums1[$i]={$nums1[$i]}, merged=" . json_encode($merged));
            $i++;
        } else {
            $merged[] = $nums2[$j];
            error_log("Added nums2[$j]={$nums2[$j]}, merged=" . json_encode($merged));
            $j++;
        }
    }
    
    // ... rest of code with debug statements
    
    // Debug: Show final merged array
    error_log("Final merged array: " . json_encode($merged));
    
    // Calculate median
    $n = count($merged);
    $median = ($n % 2 === 0) 
        ? ($merged[$n/2 - 1] + $merged[$n/2]) / 2.0
        : (float)$merged[$n/2];
    
    error_log("Median calculated: $median");
    return $median;
}
```

**In STEP 3, show both versions:**
- Version with debug (commented out)
- Clean version without debug
- Explain that debug was used during development

**This helps the user:**
- ‚úÖ Understand what each step does
- ‚úÖ Learn the approach and reasoning
- ‚úÖ Know why certain decisions were made
- ‚úÖ Follow the thought process
- ‚úÖ See the debugging/testing process (senior-level practice)
- ‚úÖ Understand how to test incrementally

## CRITICAL: DISPLAY FORMAT - NO FILES

**IMPORTANT: When showing solutions:**
- **DO NOT create or write files** - Only display code in the chat/response
- **Show code in markdown code blocks** - Display each step separately
- **Show code by parts** - Each STEP should be shown as a separate code block
- **User will copy code manually** - They will copy from the displayed code blocks to Qualified
- **Display format:** Show STEP 1, then STEP 2, then STEP 3, each in separate code blocks
- **Tests format:** Show tests for each step in separate code blocks after the corresponding code step

## CRITICAL: MANDATORY TEST GENERATION FOR EACH STEP

**Qualified platform supports TWO challenge formats:**

### Format 1: Simple Code Challenge
**3 windows:**
1. **Code editor** - Where you write your solution (editable)
2. **Tests editor** - Where you can add/edit tests manually (editable)
3. **Results** - Shows test execution results

### Format 2: Project Code Challenge (Advanced)
**Multiple sections:**
1. **Sidebar (left)** - File navigation, some files may be locked
2. **Top Toolbar** - Controls:
   - **RUN TESTS** button - Test your code (you see results)
   - **SUBMIT SOLUTION** button - Submit final solution (you DON'T see results, only one chance)
   - **Web Preview** button - For front-end challenges (if applicable)
3. **Code Entry (center)** - Multiple files, drag-and-drop layout
4. **Instructions (right)** - Challenge instructions
5. **Results Output (bottom)** - Test results after clicking RUN TESTS

**IMPORTANT for Project Code Challenges:**
- You can edit test files and add your own tests
- Your test edits are visible to reviewers but NOT used in final submission
- RUN TESTS shows you results, SUBMIT SOLUTION does NOT show results
- You can only SUBMIT once - be ready before clicking
- Some files may be locked (cannot edit)
- Files can be reset using contextual menu

**FOR EACH STEP (STEP 1, STEP 2, STEP 3), you MUST also generate corresponding tests:**

- **STEP 1 tests:** **MULTIPLE test cases** (at least 3-5) for the initial simple version to validate it works correctly from the start
  - Include: Example cases from problem description
  - Include: Basic happy path scenarios
  - Include: Simple edge cases (empty array, single element, etc.)
  - Goal: Solution should pass these tests immediately
  
- **STEP 2 tests:** Additional tests for edge cases discovered during improvements
  - Include: More complex edge cases
  - Include: Boundary conditions
  - Include: Cases that revealed bugs in STEP 1
  
- **STEP 3 tests:** Complete test suite covering ALL scenarios
  - Include: All examples from problem
  - Include: All edge cases
  - Include: Boundary conditions
  - Include: Error cases
  - Include: Performance edge cases

**This is CRITICAL because:**
- The provided tests may not cover all edge cases
- You need to manually add tests to the test editor
- Missing edge cases will cause the solution to fail
- **STEP 1 must have MULTIPLE test cases** to validate the basic solution works
- Each step should have tests that validate that specific step's functionality
- In Project Code Challenges, you can edit test files to add your own tests
- **User wants to pass tests from the first solution (STEP 1), so provide comprehensive tests from the start**

**Example: If the function should return "Hello, [name]!" OR "Hello there!" based on input:**
- **STEP 1 tests (MULTIPLE):**
  - Basic case with valid name: "Hello, Qualified!"
  - Different name: "Hello, John!"
  - Single character name: "Hello, A!"
  - Name with special characters: "Hello, Jos√©!"
  
- **STEP 2 tests (Additional):**
  - Edge case with empty name: "Hello there!"
  - Whitespace name: "Hello there!"
  
- **STEP 3 tests (Complete):**
  - All above tests PLUS:
  - Null handling
  - All whitespace variations
  - Very long names
  - Special characters edge cases

## Qualified Platform Workflow

### Recommended Workflow for Project Code Challenges:

1. **Read instructions completely** - Understand the challenge requirements
2. **üîç RESEARCH PHASE** - Look up concepts, algorithms, patterns needed
   - StackOverflow for implementation questions
   - Documentation for language/framework specifics
   - Blog posts for explanations
   - Algorithm resources for approaches
3. **Review starting code** - Explore file structure, understand existing code
4. **Review example tests** - See what's being tested
5. **Work on solution** - Implement your code following STEP 1, STEP 2, STEP 3
   - Include comments referencing research findings
   - Cite sources if using specific approaches
6. **Click RUN TESTS** - Test your code frequently (you see results)
7. **Add your own tests** - Edit test files to add edge cases
8. **Iterate** - Fix issues, add edge cases, improve solution
9. **SUBMIT SOLUTION** - Only when ready (you won't see results, only one chance)

### Important Notes:

- **RUN TESTS** = You see results, can test multiple times
- **SUBMIT SOLUTION** = Final submission, you DON'T see results, only one chance
- You can edit test files to add your own tests (visible to reviewers)
- Some files may be locked (cannot edit)
- Web Preview available for front-end challenges

## User Context
- **Level:** Senior Software Engineer
- **Primary Language:** PHP (Backend) - For Woven assessment
- **Full Stack Experience:** 
  - **Backend:** Java (Spring Framework, Spring Boot), PHP, Node.js
  - **Frontend:** React, Angular, jQuery
  - **Database:** PostgreSQL, SQL optimization, query performance
  - **APIs:** RESTful APIs, GraphQL
  - **DevOps:** Docker, CI/CD (Jenkins, GitLab CI), microservices architecture
  - **Methodologies:** Scrum, Kanban
  - **Principles:** SOLID, Design Patterns
- **Academic:** PhD in Business (in progress)
- **Research:** Co-author of scientific publication on FinTech and Blockchain
- **Purpose:** Code for Woven technical evaluation (DO NOT use AI during actual evaluation, but these rules are for preparation)
- **Language:** ALL code, comments, and documentation MUST be in ENGLISH

## CRITICAL: SENIOR-LEVEL SOLUTIONS REQUIRED

**ALL solutions MUST be written at SENIOR SOFTWARE ENGINEER level:**

### Senior-Level Code Characteristics:

1. **Architecture & Design:**
   - Apply SOLID principles appropriately
   - Use design patterns when relevant (Factory, Strategy, Repository, etc.)
   - Consider scalability and maintainability
   - Think about system architecture implications
   - Apply microservices concepts if applicable

2. **Code Quality:**
   - Clean, readable, and well-structured code
   - Meaningful variable and function names
   - Appropriate separation of concerns
   - DRY (Don't Repeat Yourself) principle
   - Proper error handling and edge cases

3. **Performance & Optimization:**
   - Consider time/space complexity
   - Database query optimization (if applicable)
   - Efficient algorithms and data structures
   - Caching strategies when relevant
   - Performance trade-offs explained

4. **Best Practices:**
   - Follow PSR standards (for PHP)
   - Proper error handling
   - Input validation
   - Security considerations
   - Testing approach

5. **Professional Experience Integration:**
   - When applicable, reference experience with:
     - Spring Framework patterns (if solving Java-like problems)
     - Database optimization techniques (PostgreSQL experience)
     - API design patterns (RESTful/GraphQL experience)
     - Microservices architecture concepts
     - DevOps practices (if deployment/infrastructure related)
   - Show understanding of real-world production scenarios

### Example: Senior-Level Approach

**NOT Junior:**
```php
// Just make it work
function solve($input) {
    // basic code
}
```

**SENIOR:**
```php
/**
 * Solves the problem using [algorithm/pattern]
 * 
 * Approach: [explain senior-level thinking]
 * - Considered [alternative approaches] but chose this because [reason]
 * - Time: O(n), Space: O(1) - optimal for this use case
 * - Trade-off: [if any]
 * 
 * Based on experience with [similar problems in production]
 */
function solve($input) {
    // Senior-level code with:
    // - Proper validation
    // - Edge case handling
    // - Clear structure
    // - Performance considerations
}
```

## General Principles

### 0. Senior-Level Solutions (MANDATORY)

**ALL solutions must reflect Senior Software Engineer level:**

- **Architectural thinking:** Consider system design, scalability, maintainability
- **Production-ready mindset:** Think about real-world scenarios, edge cases, error handling
- **Performance awareness:** Consider time/space complexity, optimization opportunities
- **Best practices:** Apply SOLID, design patterns, clean code principles
- **Professional experience:** When relevant, reference:
  - Database optimization (PostgreSQL experience)
  - API design patterns (RESTful/GraphQL)
  - Microservices architecture
  - DevOps practices
  - System integration challenges

**Even in STEP 1 (basic solution), code should show senior-level thinking:**
- Proper structure and organization
- Clear naming conventions
- Basic error handling
- Comments showing architectural considerations

### 1. Iterative and Natural Development
- **ALWAYS** show code evolution step by step
- Start with simple solution, then improve
- Include comments showing thought process
- Show decisions and tradeoffs considered
- **Display evolution in separate steps, not just final code**

### 2. Senior Code Style
- Clean and well-structured code
- Descriptive and meaningful names
- Small, focused functions
- Appropriate edge case handling
- Performance consideration when relevant
- Apply SOLID principles when applicable
- Use design patterns when appropriate
- Consider database optimization (PostgreSQL experience)
- Think about API design patterns (RESTful/GraphQL experience)
- Microservices architecture concepts when relevant
- But NOT perfect from first attempt - show evolution

### 3. Human and Natural Comments
- Comments that explain "why", not just "what"
- Mention considered alternatives
- Explain tradeoffs
- Show thought process
- Include notes about edge cases discovered during development
- **All comments in ENGLISH**

## Code Structure - MANDATORY FORMAT

### For New Functions - ALWAYS Show Evolution

**STEP 1: Initial Basic Version**
```php
// STEP 1: Initial version - basic case
function functionName($input) {
    // Basic validation first
    if (empty($input)) {
        return null; // Edge case considered
    }
    
    // Main logic - simple version
    // ...
    
    return $result;
}
```

**STEP 2: Improvements and Edge Cases**
```php
// STEP 2: Added validations after testing
// Discovered I needed to validate null user
function functionName($input) {
    // Edge cases first - learned from previous bugs
    if (empty($input) || !$input) {
        return null; // Edge case I didn't consider initially
    }
    
    // Improved logic
    // ...
    
    return $result;
}
```

**STEP 3: Final Version with Optimizations**
```php
// STEP 3: Considered optimization but not necessary for this case
// For production I'd add cache, but for this simple case it's not needed
function functionName($input) {
    if (empty($input) || !$input) {
        return null;
    }
    
    // Considered caching here but not necessary for this scenario
    // Main logic with optimizations
    // ...
    
    return $result;
}
```

### Comments Showing Process

```php
// Tried first with [approach X], but found that [problem]
// Changed to [approach Y] because [advantage]
// Considered [alternative Z] but discarded because [reason]

// Edge case discovered: [description]
// Solution: [implemented solution]
```

## Specific Patterns for Woven Evaluation

### 1. Authorization and Permissions

**STEP 1: Basic Version**
```php
/**
 * Checks if a user is authorized to access a page
 * 
 * STEP 1: Basic implementation with simple permission check
 * 
 * @param User $user The user to verify
 * @param string $pageId The page ID
 * @return bool True if has access
 */
function isUserAuthorizedForPage(User $user, string $pageId): bool {
    // Basic check
    return in_array($pageId, $user->allowedPages);
}
```

**STEP 2: Added Edge Cases**
```php
/**
 * STEP 2: Added edge case validations
 * Learned from previous bugs that null checks are critical
 */
function isUserAuthorizedForPage(User $user, string $pageId): bool {
    // Edge cases first - learned this from previous experience
    if (empty($pageId)) {
        return false; // Invalid page
    }
    
    if (!$user || !$user->isActive()) {
        return false; // Invalid or inactive user
    }
    
    // Main logic
    return in_array($pageId, $user->allowedPages);
}
```

**STEP 3: Final with Role Fallback**
```php
/**
 * STEP 3: Added role-based fallback
 * Considered checking roles first, but specific permissions have priority
 * This allows flexibility for cases where admin has general access
 * but regular user has specific permissions
 */
function isUserAuthorizedForPage(User $user, string $pageId): bool {
    // Edge cases first
    if (empty($pageId)) {
        return false;
    }
    
    if (!$user || !$user->isActive()) {
        return false;
    }
    
    // Main logic - specific permissions first
    // Considered checking roles first, but specific permissions have priority
    if ($user->hasPagePermission($pageId)) {
        return true;
    }
    
    // Fallback to role verification
    return $user->hasRole('admin') || $user->hasRole('editor');
}
```

### 2. Debugging and Problem Resolution

**STEP 1: Basic Structure**
```php
/**
 * Analyzes a bug report and provides investigation steps
 * 
 * STEP 1: Basic structure to extract information
 */
function analyzeBugReport(array $bugReport): array {
    $analysis = [
        'available_info' => [],
        'missing_info' => []
    ];
    
    // Extract available information
    if (isset($bugReport['error_message'])) {
        $analysis['available_info']['error'] = $bugReport['error_message'];
    }
    
    return $analysis;
}
```

**STEP 2: Added Missing Info Detection**
```php
/**
 * STEP 2: Added missing information detection
 * This is critical for effective debugging
 */
function analyzeBugReport(array $bugReport): array {
    $analysis = [
        'available_info' => [],
        'missing_info' => [],
        'investigation_steps' => []
    ];
    
    // Extract available information
    if (isset($bugReport['error_message'])) {
        $analysis['available_info']['error'] = $bugReport['error_message'];
    }
    
    // Identify what's missing - critical for effective debugging
    if (!isset($bugReport['steps_to_reproduce'])) {
        $analysis['missing_info'][] = 'Steps to reproduce';
    }
    
    return $analysis;
}
```

**STEP 3: Final with Investigation Steps**
```php
/**
 * STEP 3: Added investigation steps based on experience
 * Would start with logs, then code, then environment
 */
function analyzeBugReport(array $bugReport): array {
    $analysis = [
        'available_info' => [],
        'missing_info' => [],
        'investigation_steps' => [],
        'hypotheses' => []
    ];
    
    // First, extract available information
    // Note: In production I'd use a more robust parser
    if (isset($bugReport['error_message'])) {
        $analysis['available_info']['error'] = $bugReport['error_message'];
    }
    
    // Identify what's missing - critical for effective debugging
    if (!isset($bugReport['steps_to_reproduce'])) {
        $analysis['missing_info'][] = 'Steps to reproduce';
    }
    
    // Investigation steps based on experience
    // Would start with logs, then code, then environment
    $analysis['investigation_steps'] = [
        '1. Review application logs for error timestamp',
        '2. Verify if reproducible in other environments',
        '3. Review recent changes in related code'
    ];
    
    return $analysis;
}
```

### 3. Deployment and DevOps

**STEP 1: Basic Plan Structure**
```php
/**
 * Generates deployment plan for SPA
 * 
 * STEP 1: Basic structure with assumptions
 */
function generateDeploymentPlan(string $provider = 'aws'): array {
    $plan = [
        'assumptions' => [],
        'steps' => []
    ];
    
    // Clear assumptions - important for evaluation
    $plan['assumptions'] = [
        'SPA built with modern framework (React/Vue/Angular)',
        'Build process generates static files',
        'Own domain available'
    ];
    
    return $plan;
}
```

**STEP 2: Added Detailed Steps**
```php
/**
 * STEP 2: Added detailed steps
 * Balance between being specific and being clear
 */
function generateDeploymentPlan(string $provider = 'aws'): array {
    $plan = [
        'assumptions' => [],
        'steps' => [],
        'considerations' => []
    ];
    
    $plan['assumptions'] = [
        'SPA built with modern framework (React/Vue/Angular)',
        'Build process generates static files',
        'Own domain available',
        'Moderate traffic initially'
    ];
    
    // Detailed steps but not excessively technical
    // Balance between being specific and being clear
    $plan['steps'] = [
        [
            'step' => 'Build and preparation',
            'details' => [
                'Run npm run build (or equivalent)',
                'Verify all assets are included',
                'Optimize images if necessary'
            ],
            'tools' => ['npm', 'webpack/vite']
        ]
    ];
    
    return $plan;
}
```

**STEP 3: Final Complete Plan**
```php
/**
 * STEP 3: Complete plan with multiple areas
 * Approach: Cover multiple areas (breadth) with adequate detail (depth)
 * Based on AWS experience, but adaptable to other providers
 */
function generateDeploymentPlan(string $provider = 'aws'): array {
    $plan = [
        'assumptions' => [],
        'steps' => [],
        'considerations' => []
    ];
    
    // Clear assumptions - important for evaluation
    $plan['assumptions'] = [
        'SPA built with modern framework (React/Vue/Angular)',
        'Build process generates static files',
        'Own domain available',
        'Moderate traffic initially'
    ];
    
    // Detailed steps covering multiple areas
    $plan['steps'] = [
        [
            'step' => 'Build and preparation',
            'details' => [
                'Run npm run build (or equivalent)',
                'Verify all assets are included',
                'Optimize images if necessary'
            ],
            'tools' => ['npm', 'webpack/vite']
        ],
        [
            'step' => 'Static hosting',
            'details' => [
                'Create S3 bucket for static hosting',
                'Enable "Static website hosting"',
                'Configure index.html and error.html for SPA routing'
            ],
            'tools' => ['AWS S3']
        ],
        [
            'step' => 'CDN and distribution',
            'details' => [
                'Create CloudFront distribution pointing to S3',
                'Configure caching policies',
                'Enable compression'
            ],
            'tools' => ['AWS CloudFront']
        ]
    ];
    
    // Additional considerations
    $plan['considerations'] = [
        'Security: Enable HTTPS, configure CORS',
        'Performance: Cache static assets, optimize delivery',
        'Cost: Monitor S3 storage and CloudFront data transfer'
    ];
    
    return $plan;
}
```

## Specific Rules for Cursor

### When Generating Code - MANDATORY:

1. **ALWAYS show evolution in steps:**
   - **STEP 1:** Simple/commented version first
   - **STEP 2:** Improved version with edge cases
   - **STEP 3:** Final version with optimizations
   - Include comments explaining changes between steps

2. **ALWAYS display code in chat, NEVER create files:**
   - **DO NOT create or write files** - Only show code in markdown code blocks
   - **Show each STEP separately** - Each step in its own code block
   - **User will copy manually** - They copy from displayed code to Qualified
   - **Format:** Show STEP 1 code block, then STEP 1 tests, then STEP 2 code, etc.

3. **ALWAYS generate tests for EACH step:**
   - **STEP 1 Tests:** Basic test cases for initial version
   - **STEP 2 Tests:** Additional tests for edge cases discovered
   - **STEP 3 Tests:** Complete test suite covering ALL scenarios
   - Tests should be in PHPUnit format (extends TestCase)
   - Tests should be ready to copy into the Qualified test editor
   - **Display tests in separate code blocks** after each corresponding code step

4. **Test Coverage Requirements:**
   - Cover happy path (normal cases)
   - Cover edge cases (empty, null, whitespace, invalid input)
   - Cover boundary conditions
   - Cover error cases
   - Each step should add tests for the new functionality/edge cases

4. **Include process comments:**
   - "Tried first with X, but..."
   - "Improved this because..."
   - "Considered Y but discarded because..."

5. **Show discovered edge cases:**
   - Not all from the start
   - Some discovered during development
   - Mention in comments when discovered
   - **Add tests for each discovered edge case**

6. **Include natural small imperfections:**
   - Variable names that evolve
   - Minor refactorings
   - Comments showing resolved doubts

7. **Appropriate Senior level:**
   - Good practices (SOLID, clean code)
   - Performance consideration
   - Appropriate error handling
   - But NOT perfect from first attempt

8. **ALL in ENGLISH:**
   - Code comments
   - Function names (use English)
   - Variable names (use English)
   - Documentation
   - Test names and descriptions
   - Everything must be in English

### Comment Style:

```php
// ‚úÖ GOOD - Shows thought process
// Tried first with a simple loop, but it was O(n¬≤) for large datasets
// Optimized using a hash map - tradeoff: more memory but O(n)
function optimizedFunction($data) {
    // ...
}

// ‚ùå BAD - Too generic or perfect
// This function processes data efficiently
function processData($data) {
    // perfect code without context
}
```

### Code Evolution Examples with Tests:

**STEP 1: Basic solution**
```php
// STEP 1: Basic solution
function checkAccess($user, $page) {
    return in_array($page, $user->allowedPages);
}
```

**STEP 1 Tests:**
```php
class CheckAccessTest extends TestCase {
    public function testUserCanAccessAuthorizedPage() {
        $user = new User(['allowedPages' => ['page1', 'page2']]);
        $this->assertTrue(checkAccess($user, 'page1'));
    }
    
    public function testUserCannotAccessUnauthorizedPage() {
        $user = new User(['allowedPages' => ['page1']]);
        $this->assertFalse(checkAccess($user, 'page2'));
    }
}
```

**STEP 2: Added validation after testing**
```php
// STEP 2: Added validation after testing
// Discovered I needed to validate null user
function checkAccess($user, $page) {
    if (!$user) {
        return false; // Edge case I didn't consider initially
    }
    return in_array($page, $user->allowedPages);
}
```

**STEP 2 Additional Tests:**
```php
// Add these tests to the test editor
public function testNullUserReturnsFalse() {
    $this->assertFalse(checkAccess(null, 'page1'));
}

public function testEmptyPageIdReturnsFalse() {
    $user = new User(['allowedPages' => ['page1']]);
    $this->assertFalse(checkAccess($user, ''));
}
```

**STEP 3: Final version with all edge cases**
```php
// STEP 3: Optimization with cache (if needed)
// For production I'd add cache, but for this simple case it's not needed
function checkAccess($user, $page) {
    if (!$user || empty($page)) {
        return false;
    }
    // Considered caching here but not necessary for this scenario
    return in_array($page, $user->allowedPages);
}
```

**STEP 3 Complete Test Suite:**
```php
// Complete test suite covering all scenarios
public function testNullUserReturnsFalse() {
    $this->assertFalse(checkAccess(null, 'page1'));
}

public function testEmptyPageIdReturnsFalse() {
    $user = new User(['allowedPages' => ['page1']]);
    $this->assertFalse(checkAccess($user, ''));
}

public function testWhitespacePageIdReturnsFalse() {
    $user = new User(['allowedPages' => ['page1']]);
    $this->assertFalse(checkAccess($user, '   '));
}
```

## Scenario-Specific Considerations

### Scenario 1: Debugging
- Show investigation process step by step
- Identify missing information
- Propose relevant questions
- Document for engineers and non-engineers
- **All in English**

### Scenario 2: Authorization (Code)
- Clean and well-structured code
- Complete edge case handling
- Additional tests beyond provided ones
- Comments explaining decisions and tradeoffs
- **Show evolution in steps**
- **All in English**

### Scenario 3: Deployment (Writing)
- Balance between breadth (multiple areas) and depth (detail)
- Clearly stated assumptions
- Specific and executable steps
- Security, scalability, cost considerations
- **All in English**

## Important Reminders

1. **DO NOT use AI during actual evaluation** - these rules are for preparation
2. **Reasonable time** - don't solve complex problems in 2 minutes
3. **Show process** - comments explaining the "why"
4. **Natural evolution** - code that improves iteratively
5. **Appropriate level** - Senior but not perfect from start
6. **MANDATORY: Always show STEP 1, STEP 2, STEP 3 for every code generation**
7. **MANDATORY: Everything in ENGLISH**

## Complete Code Example with These Rules

```php
<?php

/**
 * Verifies user authorization for pages
 * 
 * Iterative development:
 * - V1: Basic case with simple array
 * - V2: Added edge case validations
 * - V3: Considered cache but not necessary for this case
 * 
 * Tradeoffs considered:
 * - Cache: Faster but more complex - not necessary here
 * - Role verification vs permissions: Permissions have priority
 */
class PageAuthorizationService {
    
    /**
     * STEP 1: Basic version - simple permission check
     */
    public function canAccessBasic(User $user, string $pageId): bool {
        return in_array($pageId, $user->allowedPages);
    }
    
    /**
     * STEP 2: Added edge case validations
     * Learned from previous bugs that null checks are critical
     */
    public function canAccessImproved(User $user, string $pageId): bool {
        // Edge cases first - learned from previous bugs
        if (empty($pageId)) {
            return false; // Invalid page
        }
        
        if (!$user || !$user->isActive()) {
            return false; // Invalid or inactive user
        }
        
        return in_array($pageId, $user->allowedPages);
    }
    
    /**
     * STEP 3: Final version with role fallback
     * Verifies if user can access page
     * 
     * @param User $user User to verify
     * @param string $pageId Page ID
     * @return bool True if has access
     */
    public function canAccess(User $user, string $pageId): bool {
        // Edge cases first - learned from previous bugs
        if (empty($pageId)) {
            return false; // Invalid page
        }
        
        if (!$user || !$user->isActive()) {
            return false; // Invalid or inactive user
        }
        
        // Main logic
        // Considered checking roles first, but specific permissions have priority
        // This is important for cases where an admin has general access
        // but a regular user has specific permissions
        
        if ($this->hasSpecificPermission($user, $pageId)) {
            return true;
        }
        
        // Fallback to roles - this allows flexibility
        // In production I could cache this, but for this case it's not critical
        return $this->hasRoleAccess($user);
    }
    
    /**
     * Verifies specific permission
     * 
     * Note: In production this would query a database
     * For this case I use the User model method
     */
    private function hasSpecificPermission(User $user, string $pageId): bool {
        return $user->hasPagePermission($pageId);
    }
    
    /**
     * Verifies access by roles
     * 
     * Considered making this more granular, but for this case
     * admin and editor are sufficient
     */
    private function hasRoleAccess(User $user): bool {
        return $user->hasRole('admin') || $user->hasRole('editor');
    }
}
```

---

## Complete Example: say_hello Function

This example shows how to handle a function that should return "Hello, [name]!" OR "Hello there!" based on input.

### STEP 1: Initial Basic Version

**Code:**
```php
// STEP 1: Initial version - handles basic case with name
function say_hello(string $name): string {
    $var = "Hello, $name!";
    return $var;
}
```

**STEP 1 Tests (add to test editor):**
```php
class SayHelloTest extends TestCase {
    public function testShouldSayHello() {
        $this->assertSame("Hello, Qualified!", say_hello("Qualified"));
    }
    
    public function testShouldSayHelloWithDifferentName() {
        $this->assertSame("Hello, John!", say_hello("John"));
    }
}
```

### STEP 2: Added Edge Case Handling

**Code:**
```php
// STEP 2: Added edge case for empty name
// Discovered that empty name should return "Hello there!" not "Hello, !"
function say_hello(string $name): string {
    // Edge case: empty or whitespace-only name
    if (empty(trim($name))) {
        return "Hello there!";
    }
    
    return "Hello, $name!";
}
```

**STEP 2 Additional Tests (add to test editor):**
```php
// Add these tests to catch the edge case
public function testEmptyNameReturnsHelloThere() {
    $this->assertSame("Hello there!", say_hello(""));
}

public function testWhitespaceNameReturnsHelloThere() {
    $this->assertSame("Hello there!", say_hello("   "));
    $this->assertSame("Hello there!", say_hello("\t"));
    $this->assertSame("Hello there!", say_hello("\n"));
}
```

### STEP 3: Final Version with All Edge Cases

**Code:**
```php
// STEP 3: Final version handling all edge cases
// Considered null handling but PHP type hint string prevents null
// Considered special characters but they're valid in names
function say_hello(string $name): string {
    // Edge cases: empty string or whitespace-only
    // trim() removes leading/trailing whitespace, empty() checks if result is empty
    $trimmedName = trim($name);
    if (empty($trimmedName)) {
        return "Hello there!";
    }
    
    // Normal case: return personalized greeting
    return "Hello, $trimmedName!";
}
```

**STEP 3 Complete Test Suite (final tests for test editor):**
```php
class SayHelloTest extends TestCase {
    // Basic cases
    public function testShouldSayHello() {
        $this->assertSame("Hello, Qualified!", say_hello("Qualified"));
    }
    
    public function testShouldSayHelloWithDifferentName() {
        $this->assertSame("Hello, John!", say_hello("John"));
    }
    
    // Edge cases - these are CRITICAL and were missing in initial tests
    public function testEmptyNameReturnsHelloThere() {
        $this->assertSame("Hello there!", say_hello(""));
    }
    
    public function testWhitespaceNameReturnsHelloThere() {
        $this->assertSame("Hello there!", say_hello("   "));
        $this->assertSame("Hello there!", say_hello("\t"));
        $this->assertSame("Hello there!", say_hello("\n"));
        $this->assertSame("Hello there!", say_hello(" \t\n "));
    }
    
    public function testNameWithLeadingTrailingWhitespace() {
        // Should trim whitespace but still return personalized greeting
        $this->assertSame("Hello, John!", say_hello("  John  "));
        $this->assertSame("Hello, Jane!", say_hello("\tJane\n"));
    }
    
    // Boundary cases
    public function testSingleCharacterName() {
        $this->assertSame("Hello, A!", say_hello("A"));
    }
    
    public function testNameWithSpecialCharacters() {
        $this->assertSame("Hello, O'Brien!", say_hello("O'Brien"));
        $this->assertSame("Hello, Jos√©!", say_hello("Jos√©"));
    }
}
```

**Key Learning from this example:**
- The initial test only covered the happy path
- Missing edge case tests (empty string, whitespace) caused the solution to fail
- Each step should add tests for newly discovered edge cases
- Final test suite must cover ALL scenarios mentioned in requirements

---

**Note:** These rules help you write code that looks natural and shows your thought process. During the actual evaluation, DO NOT use AI, but apply these principles when writing code manually.

**CRITICAL REMINDER:** 
- **ALWAYS show STEP 1, STEP 2, STEP 3 for EVERY code generation**
- **ALWAYS generate tests for EACH step**
- **Tests must cover edge cases discovered in each step**
- **ALL code, comments, tests, and documentation MUST be in ENGLISH**
